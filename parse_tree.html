<html>
<head>
  <link href="./screen.css" rel="stylesheet" type="text/css" />
  <title>Babel-Bridge: Ruby Parsing Expression Grammar Generator</title>
</head>
<body>
<div class="content">
<div class="babel_image">Athanasius Kircher, The Tower of Babel, 1679.</div>
<div class="title_window">
<h1 class="title">Babel Bridge</h1>
<div class="subtitle"><a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">Memoizing Parsing Expression Grammar</a> generator in Ruby</div>
<div class="nav">
  <a href="index.html">home</a>
  <a href="parsing.html">parsing</a>
  <a href="parse_tree.html" class="selected">parse tree</a>
</div>
</div>


<h1>Parse Tree Class Structure</h1>
<p>Once you are familiar with how to do <a href="parsing.html">basic parsing</a> in
Babel-Bridge, you'll want to do something with the results. The first step is
understanding the parse tree class structure.

<p>Defining a parser automatically generates several classes. For example:
<pre><code><keyword>class</keyword> <identifier>MyParser</identifier> <symbol><</symbol> <identifier>BabelBridge</identifier><symbol>:</symbol><string>:Parser</string>
  <identifier>rule</identifier> <string>:foo</string><symbol>,</symbol> <string>"foo"</string><symbol>
<keyword>end</keyword></code></pre>
<p>Generates:
<pre><code>MyParser < BabelBridge::Parser
MyParser::FooNode < BabelBridge::Node
MyParser::FooNode1 < MyParser::FooNode</pre></code>
<p>FooNode was generated by the :foo rule. It inherits from the BabelBridge::Node
class. FooNode1 represents the first (and only) varient of :foo. FooNode is
never instantiated, but FooNode1 will be created whenever the first varient of
:foo matches.
<p>irb example:
<pre><code>&gt;&gt; MyParser.new.parse("foo").class
=&gt; MyParser::FooNode1</pre></code>
<p>You can examine the children of FooNode1 with the matches method:

<pre><code>&gt;&gt; MyParser.new.parse("foo").matches
=&gt; ["foo"]
&gt;&gt; MyParser.new.parse("foo").matches[0].class
=&gt; BabelBridge::TerminalNode</code></pre>
<p>Let's do a more complex example. Below is a parser that recognizes any
number of non-negative integers concatenated by pluses. Note that the :add rule
has two variants which will create two variant sub-classes, AddNode1 and
AddNode2, of the rule's parse-tree-node class AddNode.</p>

<pre><code>class MyMathParser < BabelBridge::Parser
  rule :add, :number, "+", :add
  rule :add, :number
  rule :number, /[0-9]+/
end

puts MyMathParser.new.parse("34+12").inspect
</code></pre>
Running the code above outputs:
<pre><code>MyMathParser::AddNode1
  MyMathParser::NumberNode1 > "34"
  "+"
  MyMathParser::AddNode2 > MyMathParser::NumberNode1 > "11"</code></pre>
If you inspect the classes of the child matches of the root AddNode1, you'll get:
<pre><code>&gt;&gt; MyMathParser.new.parse("34+12").matches.collect {|m|m.class}
=&gt; [MyMathParser::NumberNode1,
    BabelBridge::TerminalNode,
    MyMathParser::AddNode2]</pre></code>
Every rule consists of one or more pattern elements which must match in order. The index of each pattern element directly corresponds
to the index of it's parse-tree-node in the matches list.

<p>There are several ways to access the children matches of a Node. All of the examples below return the parse-tree-node for the
first number:
<pre><code># returns the first matched pattern-element
MyMathParser.new.parse("34+12").matches[0]

# shortcut that also returns the first pattern-element
# '.matches' is optional
# Nodes implement Enumerable over their matches
MyMathParser.new.parse("34+12")[0]

# matched sub-rules can also be accessed by name
MyMathParser.new.parse("34+12").number
</pre></code>


<h1>Adding Functionality to the Parse Tree</h1>
<p>Manually walking the parse tree is nice and all, but things really start to get fun when we start adding
some methods to the rule-varient parse-tree-nodes. This is done adding a ruby do-block to the end of a
rule declaration. Inside this do-block you can add anything you want to that rule varient's class definition.

<p>Example:
<pre><code>class MyMathParser < BabelBridge::Parser
  rule :add, :number, "+", :add do
    def result
      number.result + add.result
    end
  end

  rule :add, :number
  rule :number, /[0-9]+/ do
    def result
      to_s.to_i
    end
  end
end

puts MyMathParser.new.parse("34+12").result
# outputs "46"</pre></code>
<p>There is a little bit of magic going on here. First, for the first varient of :add (AddNode1), we define a method "result". The result
is just the sum of the results of the left and right-hand-sides of the add operator. We can access the sub-matched parse-tree-nodes by their
rule names - in this case "number" and "add". Then we just recursively call "result" on them and add their return values.
<p>The second bit of magic is in :number's "result" method, we call to_s on self. The to_s method on a Node just returns the string of characters
that rule matched. In this case, a string of digits are returned and calling to_i on them gives us the integer value.
<p>The last bit of magic is we never define a "result" method for the second varient of :add (AddNode2). By convention, if a Node doesn't
know how to respond to a method, it forwards the method call to its first sub-match. In this case, calling "result" on AddNode2 automatically
calls "result" on the sub-matched NumberNode1.

</div>
</body></html>
